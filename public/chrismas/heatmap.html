<!DOCTYPE html>
<html ng-app="HeatingMappingApp">
   <head>
        <title>Visualization of Room</title>
		<meta charset="utf-8">
		<meta name="author" content="Steven Hassall && Sizhe Xi ">
		<meta name="description" content="Visualization of the sensor map">
	</head>
	<body>

		<section id="vis">
			<div class="content" ng-controller="mappingListCtrl">
			    <div id="loading">Loading...</div>
				    <div id="stations">
					    <div id="map-wrapper"><svg class="map"></svg></div>
						<div id="station"><h2 id="station-name"></h2>
						<div id="radial-wrapper"><svg class="radial"></svg></div>
						<div id="tiles-wrapper"><svg class="tiles"></svg></div></div>
						</div><div id="pollutant-selector"></div></div>
		</section>
			
		<div id="playground"></div>
			
		<footer><div class="content"></div></footer>
   
        
		<script src="/assets/js/jquery/jquery-1.10.2.min.js"></script>
        <script src="/assets/js/socket.io.js"></script>
        <script src="/assets/js/d3.v3.min.js"></script>
	    <script src="/assets/js/angular.min.js"></script>
	    <script src="/js/underscore-min.js"></script>
        <script src="js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>
		
	<script src="snow/three.min.js"></script>
	<script src="snow/OrbitControls.js"></script>
	<script src="snow/EasePack.min.js"></script>
	<script src="snow/TweenMax.min.js"></script>		

	<script>

var HeatingMappingApp = angular.module('HeatingMappingApp', []);
HeatingMappingApp.controller('mappingListCtrl', function ($rootScope,$scope, $http, $interval, socket) {
    
	$scope.sensors = [];
	var checkTimer ;
	
	var legend;
    var data = {};
	data.states= [{value:15,desc:'good'},{value:12,desc:'ok'},{value:9,desc:'not ok'},{value:6,desc:'bad'},{value:3,desc:'worse'}];	
	var dy = 25;
	var map ;
	
	new App();

    checkTimer = $interval($scope.checkSensorTimer, 1000*60);
    $rootScope.$broadcast('mybroadcast');	
		
				
	$scope.$on('mybroadcast', function(service){
		console.log('on my broadcast', service);
    })
			
	$scope.checkSensorTimer = function(){
	    //console.log('check timer');
	}

    $scope.dateformat = function(date){
        var date = new Date(date);	
	   	var hour = date.getHours(), min = date.getMinutes();
		if(hour < 10) hour = '0'+date.getHours();
		if(min < 10) min = '0'+date.getMinutes();
        return  hour+":"+min;		 
	}
			
    socket.on('connect', function () {
	    console.log('socket connected');
    });
                        
    socket.on('info', function (msg) {               
        //console.log(msg);
        console.log(msg.room,msg.value,msg.type)
        if(msg.type=='motion'){ 
            var room = _.findWhere($scope.rooms, {name: msg.room});	
			if(room){
                console.log('room  object  ',room);
                room.available = true;
			}	
        }
    });		


	$scope.$on('$destroy', function() {
        if (angular.isDefined(checkTimer)) {
            $interval.cancel(checkTimer);
            checkTimer = undefined;
        }
        socket.removeAllListeners();		
    });		
});

HeatingMappingApp.factory('socket', function ($rootScope) {
    if (!window.location.origin)
    window.location.origin = window.location.protocol+"//"+window.location.host;
    var socket = io.connect(window.location.origin+":3000",{'force new connection': true});
    return {
        on: function (eventName, callback) {
            socket.on(eventName, function () {  
            var args = arguments;
            $rootScope.$apply(function () {
                callback.apply(socket, args);
            });
        });
    },
        emit: function (eventName, data, callback) {
            socket.emit(eventName, data, function () {
            var args = arguments;
            $rootScope.$apply(function () {
                if (callback) {
                    callback.apply(socket, args);
                }
            });
        })
    }
  };
});

// http://www.coronaperspectives.com/src/ViewGL.js

var App = function(){

	var sw, sh, renderer, camera, scene, projector, control;
    var renderIsActive = false;	
	var plates = [];
	function init(){
	    //Scene size
	    sw = window.innerWidth;
	    sh = window.innerHeight;

	    //Setup the renderer
	    var $container = $('#playground');
	    renderer = new THREE.WebGLRenderer( { antialias: true } );
	    renderer.setSize( sw, sh );
	  
	    //Setup the camera
	    camera = new THREE.PerspectiveCamera( 45, sw / sh, 0.1, 10000 );
	    camera.position.y = 2000;
	    camera.position.z = 2000;

	    //Setup the scene
	    scene = new THREE.Scene();
	    scene.fog = new THREE.FogExp2( 0xa4e2f2, 0.0002 );
	    scene.add( camera );
	    $container.append( renderer.domElement );
	   
	    projector = new THREE.Projector();

	    //Handling window resize
	    window.addEventListener('resize', function() {
		    sw = window.innerWidth;
		    sh = window.innerHeight;
		    renderer.setSize(sw, sh);
		    camera.aspect = sw / sh;
		    camera.updateProjectionMatrix();
	    });
	  
	    //Launch the drawing loop!
	    setInterval( function(){
		    renderloop();
	    }, 1000/60 );

	    controls = new THREE.OrbitControls(camera, renderer.domElement);
	    controls.autoRotate = true;
	    cycle = 0;
	}
	
	var courtView ;
	function initScences(){
        courtView = new App.CourtView3D();		// tennis court
		//heatMapView = new APP.HeatMapView();	// heat map

		scene.add( courtView.object3D );
		//scene.add( heatMapView.object3D );
        createBaseGround();		
	}
	
	function activateVisualisation() {
        renderIsActive = true;	

    }

    function deactivateVisualisation() {
        renderIsActive = false;


    }
   
    function clear() {
	
	
	}
	
	function renderloop(){
        if ( ! renderIsActive ) return;
						
        renderer.render(scene, camera);
        controls.update();  
    }
	
	
	function createBaseGround(){
	  // width, height, depth, segmentsWidth, segmentsHeight, segmentsDepth
	  var ground = new THREE.Mesh( new THREE.CubeGeometry( 1000, 500, 1000, 5, 5, 5 ), new THREE.MeshLambertMaterial( { color: 0xffffff, shading: THREE.FlatShading } ) );
	  ground.position.y = -50;
	  groundZero = ground.position.y + 250 - 3; 
	  scene.add( ground );
	  
	  var y = -500;

	  var platesData = [  { height:70, name:'abc', texture:'' , color: 0x21b45c},{ height:15, name:'abc', texture:'', color: 0x217b45 }
						 ,{ height:15, name:'abc', texture:'' } , { height:15, name:'abc', texture:'' }
						 ,{ height:15, name:'abc', texture:'', color: 0x21b45c },{ height:80, name:'abc', texture:'', color:  0x06381a  }
					   ];
		var moonTexture = THREE.ImageUtils.loadTexture( 'images/moon.jpg' );			   
	  for(var i=0;i<platesData.length;i++){
		   var  plate = new THREE.Mesh( new THREE.CubeGeometry( 1000, platesData[i].height, 1000, 5, 5, 5 ), new THREE.MeshLambertMaterial( { color: platesData[i].color||0xffffff, shading: THREE.FlatShading } ) );
		   plate.position.y = y; y-= ( platesData[i].height +150);
		   plate.rotation.y = degToRad( 360 * Math.random() );
		   plates.push(plate);
           
		   scene.add( plate );   
	  }  

	  
	  camera.lookAt( ground.position );
	}	
	
	function degToRad( deg ){
	  return (deg * ( Math.PI / 180));
	}	
	
	init();
	initScences();
}

App.CourtView3D = function() {

	// material	
	this.material = null;
	// object3d
	this.object3D = null;
	

	var init = function() {
			
		this.material = new THREE.LineBasicMaterial( { 
			linewidth 	: 2,
			color 		: 0x999999,						
			blending 	: THREE.NormalBlending, 
			transparent : true, 
			depthTest 	: false
		} );

		var geometry = new THREE.Geometry();
		geometry.vertices = [
			// rect exterior
			new THREE.Vector3( -5.48, 0,  11.89 ), // bl 
			new THREE.Vector3(  5.48, 0,  11.89 ), // br
			new THREE.Vector3(  5.48, 0,  11.89 ), 
			new THREE.Vector3(  5.48, 0, -11.89 ), // tr
			new THREE.Vector3(  5.48, 0, -11.89 ),
			new THREE.Vector3( -5.48, 0, -11.89 ), // tl
			new THREE.Vector3( -5.48, 0, -11.89 ),
			new THREE.Vector3( -5.48, 0,  11.89 ), // bl 
			// horizontal:
			new THREE.Vector3( -4.11, 0,  6.4 ),
			new THREE.Vector3(  4.11, 0,  6.4 ),			
			new THREE.Vector3( -5.48, 0,  0 ),	   // red
			new THREE.Vector3(  5.48, 0,  0 ),
			new THREE.Vector3( -4.11, 0, -6.4 ),
			new THREE.Vector3(  4.11, 0, -6.4 ),
			// vertical
			new THREE.Vector3( -4.11,  0,  11.89 ),
			new THREE.Vector3( -4.11,  0, -11.89 ),
			new THREE.Vector3(  0,     0, -6.4 ),
			new THREE.Vector3(  0,     0,  6.4 ),
			new THREE.Vector3(  4.11,  0,  11.89 ),
			new THREE.Vector3(  4.11,  0, -11.89 ),
			new THREE.Vector3(  0,     0,  11.89 ),
			new THREE.Vector3(  0,     0,  11.50 ),
			new THREE.Vector3(  0,     0, -11.89 ),
			new THREE.Vector3(  0,     0, -11.50 )
		];  

		this.object3D = new THREE.Line( geometry, this.material, THREE.LinePieces );
		this.object3D.matrixAutoUpdate = false;	

		this.material.opacity = 0.2;

	}

    init();	
	
};


// ---------------------------------------------------------------------------------------------------------------------
// Heat map
// ---------------------------------------------------------------------------------------------------------------------

/*
APP.HeatMapView = function() {

	// rtt stuff

	this.particlesMaterial = null;
	this.particles = null;

	this.sceneRTT = null;
	this.cameraRTT = null;
	this.renderTarget = null;

	this.particleTexture = null;
	this.particleTexture = null;

	// plane material

	this.uniforms = null;
	this.material = null;

	// object3d (plane)

	this.object3D = null;

	// init

	this.init();

};

APP.HeatMapView.prototype = {

	init: function() {

		// rtt 

		var resolution  = 20,
			planeWidth  = 12.8,
			planeHeight = 32;

		this.cameraRTT = new THREE.OrthographicCamera( -planeWidth/2, planeWidth/2, planeHeight/2, -planeHeight/2, -1000, 1000 );
		this.cameraRTT.rotation.x = -Math.PI / 2;
		this.cameraRTT.position.set( 0, 10, 0 );
		this.cameraRTT.matrixAutoUpdate = false;
		this.cameraRTT.updateMatrix();

		this.sceneRTT = new THREE.Scene();

		this.renderTarget = new THREE.WebGLRenderTarget( planeWidth * resolution, planeHeight * resolution, { 
			minFilter : THREE.LinearFilter, 
			magFilter : THREE.LinearFilter,
			format    : THREE.RGBFormat
		});	

		this.particleTexture = THREE.ImageUtils.loadTexture( "./css/particle.png" );
		this.gradientTexture = THREE.ImageUtils.loadTexture( "./css/gradient.png" );

		// particle material
		this.particlesMaterial =  new THREE.ParticleBasicMaterial( { 
			map        : this.particleTexture,
			size       : 1.0,
			opacity    : 1.0,
			blending   : THREE.AdditiveBlending,					
			depthWrite : false,
			// transparent : true
		});

		// plane material
		this.uniforms = {
			uTexArray : { type: "tv", value: 2, texture: [ this.renderTarget, this.gradientTexture ] }
		};
		this.material = new THREE.ShaderMaterial( {
			uniforms	   : this.uniforms,
			vertexShader   : APP.HeatMapView.vertexShader,
			fragmentShader : APP.HeatMapView.fragmentShader,
			blending	   : THREE.AdditiveBlending,
			depthTest	   : false,
			side           : THREE.DoubleSide
			// transparent	   : true
		});

		// plane object

		var geometry = new THREE.PlaneGeometry( planeWidth, planeHeight );

		this.object3D = new THREE.Mesh( geometry, this.material );
		this.object3D.rotation.x = - Math.PI/2;	
		this.object3D.updateMatrix();
		this.object3D.matrixAutoUpdate = false;

	},

	generateHeatmap: function( node ) {

		var geometry = new THREE.Geometry();
		var vertices, vertex, prevVertex;

		// get bounces on the floor (fill geometry)		

		APP.Iterator.preorder( node, function( node ) {

			if ( node.data.kind !== 'arc' ) 
				return;

			vertices = node.data.vertices;

			for ( i = 0, l = vertices.length; i < l; i ++ ) {

				vertex = vertices[ i ];

				if ( vertex.y === 0  &&  ! vertex.equals( prevVertex ) ) {

					geometry.vertices.push( vertex.clone() );
				}

				prevVertex = vertex;
			}
		});

		// create particle system (to be rendered into renderTarget)

		if ( this.particles )
			this.sceneRTT.remove( this.particles );

		this.particles = new THREE.ParticleSystem( geometry, this.particlesMaterial );
		this.sceneRTT.add( this.particles );
		
	},

	render: function( renderer ) {

		// Render particle scene into texture
		renderer.render( this.sceneRTT, this.cameraRTT, this.renderTarget, true );

	},

	setThreshlod : function( value ) {

		this.particles.material.opacity = value;

	},

	setHeatScale : function( value ) {

		this.cameraRTT.position.y = 1 + value;
		this.cameraRTT.updateMatrix();

	}
};

APP.HeatMapView.vertexShader = [

	"varying vec2 vUv;",

	"void main() {",

	"	vUv = uv;",

	"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

	"}"

].join('\n');

APP.HeatMapView.fragmentShader = [
	
	"varying vec2 vUv;",

	"uniform sampler2D uTexArray[ 2 ];",	// textures only appear to work when contained in array?

	"void main() {",

	// "	gl_FragColor = texture2D( uTexArray[ 0 ], vUv );",
		
	"	float brighness = texture2D( uTexArray[ 0 ], vUv ).r;",			
		
	"	gl_FragColor = texture2D( uTexArray[ 1 ], vec2( brighness, 0.0 ) );",

	"}"

].join('\n');
*/	  
	</script>
    </body>
</html>