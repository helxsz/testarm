<!DOCTYPE html>
<html ng-app="SensorMappingApp">
   <head>
        <title>Visualization of Room</title>
		<meta charset="utf-8">
		<meta name="author" content="Steven Hassall && Sizhe Xi ">
		<meta name="description" content="Visualization of the sensor map">
	</head>
	<body style="background:black">
<style type="text/css">

div.tooltip {
  position: absolute;
  text-align: center;
  width: 60px;
  height: 12px;
  padding: 8px;
  font: 10px sans-serif;
  background: #ddd;
  border: solid 1px #aaa;
  border-radius: 8px;
  pointer-events: none;
}

path {
	stroke: steelblue;
	stroke-width: 1;
	fill: none;
}

.area {
    fill: lightsteelblue;
    stroke-width: 0;
}

</style>
		<section id="vis">
			<div class="content" ng-controller="mappingListCtrl">
				<div id="stations">
					<div id="map-wrapper"><svg class="map"></svg></div>
					<!--<div id="tiles-wrapper"><svg class="tiles"></svg></div></div>-->
				</div>			
			</div>
		</section>
		
		<div id="graph" class="aGraph" style="position:absolute;top:0px;left:0; float:left; width:300px; height:60px;"></div>
	
		<footer><div class="content"></div></footer>
        
		<script src="/assets/js/heatmap.js"></script>
        <script src="/assets/js/socket.io.js"></script>
        <script src="/assets/js/d3.v3.min.js"></script>
	    <script src="/assets/js/angular.min.js"></script>
	    <script src="/js/underscore-min.js"></script>
        <script src="js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>

	<script>

/*			
	var textPollutant = (function() {
        var mapping = {
            all: 'All',
            no2: 'NO2',
            so2: 'SO2',
            pm2_5: 'PM2.5',
            pm10: 'PM10'
        };
        return function(codename) {
            return mapping[codename];
        };
    })();
	console.log(textPollutant('all'));	

 	d3.csv('data/values.csv', function(values) {
		values.forEach(function(d){
			//console.log(d.id,d.place,d.time,d.so2,d.no2,d.pm2_5,d.pm10);				
		})
		
		vis2({
          values: values
        });
	})   
	
	var vis2 = function(data) {
	
	    var places = d3.nest().key(function(d) {
            return d.place;
        }).entries(data.values);		
		places.forEach(function(d){
		
		    //console.log('places',d.key, d.values);
			var mean = d3.mean(d.values,function(e){
			    return e.so2;
			}) 
			console.log('mean',d.key,mean);
			
		})
		
		var times = d3.nest().key(function(d) {
           return d.time;
        }).entries(data.values);
		times.forEach(function(d){
		    
		    //console.log('times',d.key,d.values);
			d3.mean(d.values,function(e){
			    return e.value;
			})			
		})
		
		//console.log(places);
		//console.log(times);
	}
*/	
	//////////////////////////////////////////////////

// http://blog.dewmap.com/post/50ff83c23f9c1f0200000001
// http://blog.dewmap.com/post/512c13141e26170200000001
// http://dewmap.com/experiment/three-angular-01/index.html#/sale/kids
// http://cssensei.com/how-to-use-angularjs-with-requirejs-jquery-webgl-and-three-js.html	

// http://blog.repustate.com/twitter-postgis-d3-rob-ford-fun-with-data-visualizations/2013/12/03/
// https://gist.github.com/mbostock/899711
// http://markmarkoh.com/blog/d3-dot-js-animated-map-visualization/
// http://bl.ocks.org/mbostock/2206590
// http://bost.ocks.org/mike/map/
// http://ska-la.blogspot.be/2013/08/mid-2013-my-spark-odyssey-rolling-out.html
// http://markmarkoh.com/tracker/

// floor map
// https://github.com/dciarletta/d3-floorplan/
// http://bost.ocks.org/mike/leaflet/
// http://stackoverflow.com/questions/18735718/how-to-create-floor-plans-that-work-nice-with-mobile-and-desktop-browsers


// heat map
// https://chromium.googlesource.com/syzygy/+/master/simulate/d3/heatmap.js
// http://bl.ocks.org/tjdecke/5558084
// https://github.com/kamisama/cal-heatmap


// http://artzub.com/d3/wbca/  http://cesiumjs.org/demos/d3.html   http://cesiumjs.org/d3cesium/  http://bl.ocks.org/bunkat/1962173
// rotation http://stackoverflow.com/questions/13313043/d3-js-animate-rotation
var SensormappingApp = angular.module('SensorMappingApp', []);
SensormappingApp.controller('mappingListCtrl', function ($rootScope,$scope, $http, $interval, socket) {
    
	$scope.sensors = [];
	var checkTimer ;
	
	var legend;
    var data = {};
	data.states= [{value:15,desc:'good'},{value:12,desc:'ok'},{value:9,desc:'not ok'},{value:6,desc:'bad'},{value:3,desc:'worse'}];	
	var dy = 25;
	var map ;
	
	$scope.initGrapth = function(){
	    console.log('init grapth');
	    legend = d3.select('svg.map').append('g').attr('class','legend').attr('transform', 'translate(450, 200)');
	    render();	
	}
		
	$scope.loadSensorData = function(){
        $http.get('/sensors/arm/').success(function(data) {
            $scope.sensors = data.sensors;
	        console.log(data.sensors);
	        data.sensors.forEach(function(sensor){
	            console.log(sensor.name);
	        })
		    
        }).error(function(data, status, headers, config) {
                // called asynchronously if an error occurs
                // or server returns response with an error status.
        });
	}
	
	$scope.loadMapData =function(){
	    d3.csv('data/location-coord.csv', function(coord) {
		    for (var j = 0; j < coord.length; j++) {
                console.log(coord[j].x,coord[j].y);
            }
			data.maps = coord;
			
			//map = new LocationMap();
			building = new BuildingMap();
			console.log('mapping loading  success',data.maps);
		})
	}
	
	$scope.initGrapth();
	$scope.loadSensorData();
	$scope.loadMapData();	
    checkTimer = $interval($scope.checkSensorTimer, 1000*60);
    $rootScope.$broadcast('mybroadcast');	
		
				
	$scope.$on('mybroadcast', function(service){
		console.log('on my broadcast', service);
    })
			
	$scope.checkSensorTimer = function(){
	    //console.log('check timer');
	}

    $scope.dateformat = function(date){
        var date = new Date(date);	
	   	var hour = date.getHours(), min = date.getMinutes();
		if(hour < 10) hour = '0'+date.getHours();
		if(min < 10) min = '0'+date.getMinutes();
        return  hour+":"+min;		 
	}
			
    socket.on('connect', function () {
	    console.log('socket connected');
    });
	
    socket.on('error', function (reason){
		stats.style("top","0px").select("div").text("Connecting...");				
		console.error('Unable to connect Socket.IO', reason);
	});	
                        
    socket.on('info', function (msg) {               
        //console.log(msg);
        console.log(msg.room,msg.value,msg.type)
        if(msg.type=='motion'){ 
            var room = _.findWhere($scope.rooms, {name: msg.room});	
			if(room){
                console.log('room  object  ',room);
                room.available = true;
			}	
        }
    });		
	
	
  // plot map
  var LocationMap = function() {
    var map = {};

    var margin = {
      top: 5,
      right: 5,
      bottom: 5,
      left: 5
    };
    var ratio = .6;
    var width = 1852 * ratio;
    var height = 1792 * ratio;

    var mapSVG = d3.select('svg.map')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom)
      .append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

	  
    console.log('mapping   ',data.maps);    
	
    var path = d3.geo.path();
    mapSVG.append('path')
      .datum(data.maps)
      .attr('class', 'map')
      .attr('d', function() {
        var getMappedCoord = function(i) {
          return data.maps[i].x * ratio + ',' + data.maps[i].y * ratio;
        };
        var ret = 'M' + getMappedCoord(0);
        var len = data.maps.length;
        for (var i = 1; i < len; i++) {
          ret += 'L' + getMappedCoord(i);
        }
        ret += 'Z';
        return ret;
      });

    var radiusRange = [1, 15];
    
    mapSVG.selectAll('.location')
      .data($scope.sensors)
      .enter().append('circle')
        .attr('class', 'location')
        .attr('cx', function(d) {
          return d.x * ratio;
        })
        .attr('cy', function(d) {
          return d.y * ratio;
        })
        .on('click', function(d) {
          d3.event.stopPropagation();
        });
    
    map.plot = function(opt) {
	    /*
        mapSVG.selectAll('.map')
        .classed('active', function() {
          return (opt.scope === 'all');
        })
        .transition()
          .style('fill', function() {
            return colors[opt.pollutant][1];
          })
          .style('stroke', function() {
            return colors[opt.pollutant][8];
        });

        // update locations
        mapSVG.selectAll('.location')
        .classed('active', function(d) {
          return (opt.scope === 'station' && opt.id === d.id);
        })
        */    
    };

    return map;
  };
  
  
  
  

   
  
  
  
  


    function render(){	
	    console.log('render  ...');

	      	
	    legend.selectAll('text11').data(data.states).enter().append('text')
	        .attr('class', 'legend-element')
	        .attr('x',15)
	        .attr('y',function(e,i){return dy*i})      
	        .attr('dy', '.375em')	      
		    .transition()
            .duration(2500)
            .delay(function(d, i) { return i * 400; })
		    .text(function(e,i){  return e.desc;   });    	
	}

	$scope.$on('$destroy', function() {
        if (angular.isDefined(checkTimer)) {
            $interval.cancel(checkTimer);
            checkTimer = undefined;
        }
        socket.removeAllListeners();		
    });		
});

SensormappingApp.factory('socket', function ($rootScope) {
    if (!window.location.origin)
    window.location.origin = window.location.protocol+"//"+window.location.host;
    var socket = io.connect(window.location.origin+":3000",{'force new connection': true});
    return {
        on: function (eventName, callback) {
            socket.on(eventName, function () {  
            var args = arguments;
            $rootScope.$apply(function () {
                callback.apply(socket, args);
            });
        });
    },
        emit: function (eventName, data, callback) {
            socket.emit(eventName, data, function () {
            var args = arguments;
            $rootScope.$apply(function () {
                if (callback) {
                    callback.apply(socket, args);
                }
            });
        })
    }
  };
});
	

// plot map
var BuildingMap = function() {
var map = {};

var color = d3.scale.linear()
	.domain([95, 115, 135, 155, 175, 195])
	.range(["#0a0", "#6c0", "#ee0", "#eb4", "#eb9", "#fff"]);	
/*  color http://bl.ocks.org/mbostock/4241134   timeline http://bl.ocks.org/bunkat/1962173
var svg = d3.select("body").append("svg:svg")
	.attr("width", w)
	.attr("height", h);
*/		
var svg = d3.select('svg.map');	
var offset_x = 550, offset_y = 250;


////////////////////////////////////////
function addFloor(){
	svg.append("svg:g")
	   .attr("transform", "translate(" + (offset_x ) + "," + (offset_y) + ")")  //scale(2)   rotate(-15)
	   .append("svg:rect")
		.attr("width", 680)
		.attr("height", 340)
		.style("stroke", "#134D61")
		.style("fill", "#092630")
		.on("mouseover", mouseover)
		.on("mousemove", mousemove)
		.on("mouseout", mouseout)
		.on("click", click)
		/*  http://stackoverflow.com/questions/10831920/linear-incremental-rotation-animation-with-transition  http://stackoverflow.com/questions/13313043/d3-js-animate-rotation
		.transition().attrTween("transform", function(d) {
			return d3.interpolateString(
				"rotate(-15) "
			 );
		});*/
		
	var div = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 1e-6);
	function mouseover() {
	  div.transition()
		  .duration(500)
		  .style("opacity", 1);
	}

	function mousemove() {
	  div.text(d3.event.pageX + ", " + d3.event.pageY)
		 .style("left", (d3.event.pageX - 34) + "px")
		 .style("top", (d3.event.pageY - 12) + "px");
	}

	function mouseout() {
	  div.transition()
		 .duration(500)
		 .style("opacity", 1e-6);
	}	

	function click(){
	  // Ignore the click event if it was suppressed
	  if (d3.event.defaultPrevented) return;
	  
	  // Extract the click location\    
	  var point = d3.mouse(this) , p = {x: point[0], y: point[1] };
	 
	  console.log(p.x, p.y);
	  // Append a new point
	  svg.append("circle")
		  .attr("transform", "translate(" + (offset_x +p.x) + "," + (offset_y +p.y) + ")")  //scale(2)
		  .attr("r", "5")
		  .attr("class", "dot")
		  .style("cursor", "pointer")
		  .call(drag);
	  d3.event.stopPropagation();	  
	}
		
	// Define drag beavior
	var drag = d3.behavior.drag()
		.on("drag", dragmove);

	function dragmove(d) {
	   var x = d3.event.x;
	   var y = d3.event.y;
	   d3.select(this).attr("transform", "translate(" + x + "," + y + ")");
	}	


}	

function addSensors(){
	/*
	Primary Blue:       #2599C1;
	Mid Blue:           #134D61;
	Dark Blue:          #092630;

	Primary Pink:       #CE1D6F;
	Mid Pink:           #9B1653;
	Dark Pink:          ;	
	
	*/
	  // Append a sensor point
	var sensors = [
		{x:170 , y:140  , t:18},
		{x:10 , y:240 , t:4},
		{x:60 , y:150 , t:27},
		{x:30 , y:120 , t:27}		
	]; 	  
		
	svg.selectAll('circle111').attr("transform", "translate(" + (offset_x ) + "," + (offset_y) + ")rotate(-15)")
		.data(sensors)
		.enter()		
		.append('circle')
		.on( "mousedown", function() {
			if( !d3.event.ctrlKey) d3.selectAll( '.selected').classed( "selected", false);
			console.log("mouse down");
			var p = d3.mouse( this);
			svg.append( "rect")
				.attr({
					rx      : 6,
					ry      : 6,
					class   : "selection",
					x       : p[0],
					y       : p[1],
					width   : 0,
					height  : 0
				})
		})		
		.attr('cx',function(e,i){return offset_x +e.x})
		.attr('cy',function(e,i){ return offset_y+e.y})
		.attr('r',function(e){
			return e.t * 2
		})
		.on( "mouseup", function() { 
			svg.selectAll( "rect.selection").remove();
			d3.selectAll( '.selection').classed( "selection", false);
		})
		.style('fill', function(e,i) {
			return "#620F3a" ;
		})

	var sensor = svg.selectAll('circle111').attr("transform", "translate(" + (offset_x ) + "," + (offset_y) + ")rotate(-15)")
		.data(sensors)
		.enter()
		.append('circle')
		.attr('cx',function(e,i){return offset_x +e.x})
		.attr('cy',function(e,i){ return offset_y+e.y})
		.attr('r',function(e){
			return e.t
		})
		.attr("class", "dot")
		.on('mouseover', function(d) { 
			d3.select(this)
			  .attr('fill', function(d) { return d3.rgb(d.color).brighter() })
			  .transition()
			  .attr('r', 24*2)
		  })
		.on('mouseout', function(d) {
			d3.select(this)
			  //.attr('fill', 'white')
			  .transition()
			  .attr('r', 24)
		  })    		  
		.style("cursor", "pointer")
		.transition()
		.style('fill', function(e,i) {
			if(e.t<=15) 
			return "#670F38" ;
			else if(e.t>=16 && e.t<=22)
			return "#9B1653";
			else if(e.t> 23)
			return "#CE1D6F";
		})
		.style("opacity",0.6);	


}


	// draw legend
function showLegend() {
  var dy = 36;

  var mapLegend = d3.select('svg.map')
	.append('g')
	  .attr('class', 'legend')
	  .attr('transform', 'translate(150, 500)');
  var legendData = [
	{
	  value: 19,
	  desc: '23 - 30',
	  color: ' #CE1D6F'
	},
	{
	  value: 17,
	  desc: '15 -22',
	  color: ' #9B1653'
	},
	{
	  value: 15,
	  desc: '1 - 14',
	  color: ' #670F38'
	}
  ];
  mapLegend.selectAll('circle.legend-element')
	.data(legendData)
	.enter().append('circle')
	  .attr('class', 'legend-element')
	  .attr('cx', 0)
	  .attr('cy', function(d, i) {
		return i * dy;
	  })
	  .attr('r', function(d) {
		return d.value;
	  })
	  .style('fill', function(e,i) {
			return e.color;
	  });
  mapLegend.selectAll('text.legend-element')
	.data(legendData)
	.enter().append('text')
	  .attr('class', 'legend-element')
	  .attr('x', 20)
	  .attr('y', function(d, i) {
		return i * dy;
	  })
	  .attr('dy', '.375em')
	  .text(function(d) {
		return d.desc;
	  })
	  .style("stroke", "#134D61");
};


//  problem 
//sensor.exit().transition().style("opacity",1e-6).remove();
  ////////////////////////////////////////


addFloor();
addSensors();	
showLegend();
return map;
};	

/*
function timeline(){
// http://www.seaoftweets.com/js/c.js  http://scottcheng.github.io/weibo-time-vis/  https://github.com/scottcheng/weibo-time-vis/blob/gh-pages/javascripts/vis.js  https://github.com/scottcheng/bj-air-vis/blob/gh-pages/air-vis.js
    var colors={
		"bersani":"#d90033",
		"letta":"#fff",
		"grillo":"#ffe500",
		"renzi":"#7fff00",
		"berlusconi":"#0d88cb",
		"epifani":"#ff6600"
	};
	var viz=d3.select("#viz");		

	var width=window.innerWidth,
		height=viz.node().offsetHeight;
		
	var svg=viz
			.append("svg")
			.attr("width",width)
			.attr("height",height);
	var grid=svg.append("g")
				.attr("id","grid");

	var timeline=svg.append("g")
				.attr("id","timeline");
	var tweets=svg.append("g")
				.attr("id","tweets")
    
	var formathhmmss = d3.time.format("%I:%M:%S");				
	var arc = d3.svg.arc()
				.outerRadius(50)
				.innerRadius(0);

}

var statusStack = (function() {
    var statusStack = {};
    var stackTop = layersTop - layerHeightExpanded / 2;
    var stackLeft = axisW + marginIn;
    var stackHeight = layerHeight * nLayers;
    var stackWidth = stackW;
	  
   //nest by time within topics
    var nTimeBucket = 40;
    var timeScale = d3.scale.linear()
        .domain([d3.min(data.statuses.values, function(d) {
          return d.created_at_time;
        }), d3.max(data.statuses.values, function(d) {
          return d.created_at_time;
        })])
        .rangeRound([0, nTimeBucket]);	  

    var areaXScale = d3.scale.linear()
        // .exponent(.5)
        .domain([0, d3.max(data.statuses.byTopic[data.statuses.byTopic.length-1].byTime, function(d) {
          return d.y0 + d.y;
        })])
        .range([stackLeft, stackLeft + stackWidth]);
    var areaYScale = d3.scale.linear()
        .domain([0, nTimeBucket])
        .range([stackTop, stackTop + stackHeight]);
    var area = d3.svg.area()
        .y(function(d) {
          return areaYScale(d.x);
        })
        .x0(function(d) {
          return areaXScale(d.y0);
        })
        .x1(function(d) {
          return areaXScale(d.y + d.y0);
        });		
      var statusStackG = d3.select('g#status-stack-wrapper');
      var stackPaths = statusStackG
        .selectAll('path.status-stack-layer')
        .data(data.statuses.byTopic).enter()
        .append('path')
        .attr('class', 'status-stack-layer')
        .attr('d', function(d) {
          return area(d.byTime);
        })
        .style('fill', function(d) {
          return colors[topicOrdinal(d.key)][5];
        })
        .attr('title', function(d) {
          return d.key + '<span style="margin-left:10px">' + d.values.length.format() + ' statuses</span>';
        });		
};
*/	  

// try to caculate the motion sensor number per meeting per room 
// 

var format = d3.time.format("%a %b %d %Y");
var dateFn = function(d) { return format.parse(d.t) };
var colors={
	"bersani":"#d90033",
	"letta":"#fff",
	"grillo":"#ffe500",
	"renzi":"#7fff00",
	"berlusconi":"#0d88cb",
	"epifani":"#ff6600"
};

var data2 = [ {v:3},{v:6},{v:7},{v:5},{v:2},{v:4},{v:8},{v:9},{v:1},{v:3},{v:8},{v:3},{v:6},{v:8},{v:1},{v:3},{v:8},{v:5},{v:2},{v:1}];

var x = d3.scale.linear().domain([0, 10]).range([0, 90]);
console.log('------------------------------------' ,   d3.min( data2, function(d) {  return d.v;  }   )   );
var y = d3.scale.linear().domain([  d3.min( data2, function(d){return d.v;  }) - 1,
                                    d3.max( data2, function(d){return d.v;  }) + 1               
								 ])
						 .range([0, 30]);
/////
var amountFn = function(d) { return d.v };
y = d3.scale.linear().domain( d3.extent(data2, amountFn) ).range([0, 30]);						 

// area chart
var area = d3.svg.area()
    .x(function(d,i) { return x(i); })
    .y0(30)
    .y1(function(d) { return y(d.v); });
	

		
// line chart
var line = d3.svg.line()
	.x(function(d,i) { 
		console.log('Plotting X value for data point: ' + d + ' using index: ' + i + ' to be at: ' + x(i) + ' using our xScale.');
		return x(i); 
	})
	.y(function(d) { 
		console.log('Plotting Y value for data point: ' + d.v + ' to be at: ' + y(d.v) + " using our yScale.");
		return y(d.v); 
})		


/*http://stackoverflow.com/questions/11676286/d3-append-and-enter-issues    http://stackoverflow.com/questions/13832625/d3-js-uncaught-typeerror-object-has-no-method-exit*/
var graph = d3.select("#graph").append("svg:svg").attr("width", "400px").attr("height", "100px");
var inter = setInterval(function() {
    
	var updateData = function(){
	
	    data2.push( {v: Math.random(1+10)*10} )
		
	    var areachart = graph.append("path").attr('id','chart1');
					
		areachart.datum(data2)
		    .attr("class", "area")
			.attr("d", area)
			.style("fill",function(){ return colors['bersani'] })
			.filter(function(d) { return d.v > 6 })  
			.style("fill",function(){ return colors['epifani'] });
		
		graph.selectAll('chart1').enter().attr("transform",function(d){
		    console.log('enter');
            x = -5;
			return "translate("+x+")"
		})
		///////////////////////////////////////////////////////////////
        var linechart = graph.append("svg:path").attr("d", line(data2));	   
	}
	updateData();
}, 1000); 



/*
function redraw() {

  var rect = chart.selectAll("rect")
      .data(data, function(d) { return d.time; });

  rect.enter()
      .insert("rect", "line")
      .call(onEnter);
      .transition().call(onEnterTrans);

  rect.transition()
      .call(onTrans)

  rect.exit()
      .call(onExit)
      .transistion().call(onExitTrans);
}


function onEnter() {
  this.attr("x", function(d, i) { return x(i + 1) - .5; })
      .attr("y", function(d) { return h - y(d.value) - .5; })
      .attr("width", w)
      .attr("height", function(d) { return y(d.value); });
}

function onEnterTrans() {
  this
      .duration(1000)
      .attr("x", function(d, i) { return x(i) - .5; });
}

function onTrans() {
  this.attr("x", function(d, i) { return x(i) - .5; });
}

function onExit() {
  // nothing to do
}

function onExitTrans() {
  this.duration(1000)
      .attr("x", function(d, i) { return x(i - 1) - .5; })
      .remove();
}
*/

</script>
    </body>
</html>




